#' @importFrom methods setClass setClassUnion setValidity prototype
#' @importFrom stringr str_replace str_detect ignore.case
#' @importFrom assertthat validate_that
#' @include ganalytics-package.R
#' @include helper-functions.R
NULL

# Class definitions for ganalytics
# --------------------------------

# ---- GA dimension and metric variables ----

setClass(
  Class = "gaMetVar",
  prototype = prototype("ga:sessions"),
  contains = "character",
  validity = function(object) {
    if (IsVarMatch(object@.Data, kGaVars$mets)) {
      TRUE
    } else {
      paste("Invalid GA metric name", object@.Data, sep = ": ")
    }
  }
)

#   dateOfSession is a special dimension
#   #dateOfSession<>2014-05-20_2014-05-30

setClass(
  Class = "gaDimVar",
  prototype = prototype("ga:date"),
  contains = "character",
  validity = function(object) {
    if (IsVarMatch(object@.Data, union("dateOfSession", kGaVars$dims))) {
      TRUE
    } else {
      paste("Invalid GA dimension name", object@.Data, sep = ": ")
    }
  }
)

setClassUnion(
  name = ".gaVar",
  members = c("gaMetVar", "gaDimVar")
)

setValidity(
  Class = ".gaVar",
  method = function(object) {
    validate_that(length(object) == 1)
  }
)

# ---- GA expression operators ----

setClass(
  Class = "gaMetOperator",
  contains = "character",
  prototype = prototype("=="),
  validity = function(object) {
    if (object@.Data %in% kGaOps$met) {
      TRUE
    } else {
      paste("Invalid metric operator", object@.Data, sep = ": ")
    }
  }
)

setClass(
  Class = "gaDimOperator",
  contains = "character",
  prototype = prototype("=="),
  validity = function(object) {
    if (object@.Data %in% kGaOps$dim) {
      TRUE
    } else {
      paste("Invalid dimension operator", object@.Data, sep = ": ")
    }
  }
)

setClassUnion(
  name = ".gaOperator",
  members = c("gaMetOperator", "gaDimOperator")
)

setValidity(
  Class = ".gaOperator",
  method = function(object) {
    validate_that(length(object) == 1)
  }
)

# ---- GA expression operands ----

setClass(
  Class = "gaMetOperand",
  contains = "numeric",
  validity = function(object) {
    if (!(length(object) %in% c(1, 2))) {
      "A gaMetOperand must be of length 1 or 2"
    } else if (any(is.na(object))) {
      "A gaMetOperand connot contain NA values"
    } else if (length(object) == 2) {
      if (object[1] > object[2]) {
        "The first value in a range must not be greater than the second"
      } else TRUE
    } else TRUE
  }
)

setClass(
  Class = "gaDimOperand",
  contains = "character",
  validity = function(object) {
    validate_that(
      length(object) >= 1,
      length(object) <= 10
    )
  }
)

setClassUnion(
  name = ".gaOperand",
  members = c("gaMetOperand", "gaDimOperand")
)

# ---- GA simple expressions -------------------------------------------------------

setClass(
  Class = ".gaExpr",
  slots = c(
    gaVar = ".gaVar",
    gaOperator = ".gaOperator",
    gaOperand = ".gaOperand"
  ),
  contains = "VIRTUAL"
)

setClass(
  Class = "gaMetExpr",
  contains = ".gaExpr",
  validity = function(object) {
    valid <- validate_that(
      is(object@gaVar, "gaMetVar"),
      is(object@gaOperator, "gaMetOperator"),
      is(object@gaOperand, "gaMetOperand")
    )
    if (valid == TRUE) {
      if (object@gaOperator != "<>") {
        if (length(object@gaOperand) != 1) {
          "gaOperand must be of length 1 unless using a range operator '<>'."
        } else TRUE
      } else {
        if (length(object@gaOperand) != 2) {
          "gaOperand must be of length 2 when using a range operator '<>'."
        } else TRUE
      }
    } else valid
  }
)

setClass(
  Class = "gaSegMetExpr",
  slots = c(
    metricScope = "character"
  ),
  prototype = prototype(
    metricScope = "perSession"
  ),
  contains = "gaMetExpr",
  validity = function(object) {
    validate_that(
      length(object@metricScope) == 1,
      object@metricScope %in% c("perUser", "perSession", "perHit")
    )
  }
)

setClass(
  Class = "gaDimExpr",
  contains = ".gaExpr",
  validity = function(object) {
    valid <- validate_that(
      is(object@gaVar, "gaDimVar"),
      is(object@gaOperator, "gaDimOperator"),
      is(object@gaOperand, "gaDimOperand")
    )
    if (valid == TRUE) {
      if (object@gaOperator == "<>") {
        rangeDimVars <- unlist(kGaDimTypes[c("nums", "dates", "orderedIntFactors")], use.names = FALSE)
        if (!(object@gaVar %in% rangeDimVars)) {
          return("A range operator only supports numerical dimensions or metrics")
        }
      }
      if (!(length(object@gaOperand) == 1 | object@gaOperator %in% c("<>", "[]"))) {
        return("gaOperand must be of length 1 unless using a range '<>' or list '[]' operator.")
      } else if (!(length(object@gaOperand) <= 2 | object@gaOperator == "[]")) {
        return("gaOperand may only be greater than length 2 if using a list operator '[]'.")
      } else if (GaIsRegEx(object@gaOperator)) {
        if (nchar(object@gaOperand) > 128) {
          return(paste0("Regular expressions in GA Dimension Expressions cannot exceed 128 chars. Length = ", nchar(object@gaOperand)))
        }
      }
      if (object@gaOperator %in% c("!=", "==", "<>", "[]")) {
        ValidGaOperand(object@gaVar, object@gaOperand)
      } else TRUE
    } else valid
  }
)

# ---- GA 'AND' and 'OR' compound expressions -------------------------------

setClass(
  Class = "gaOr",
  contains = "list",
  validity = function(object) {
    if (all(sapply(object@.Data, inherits, ".gaExpr"))) {
      TRUE
    } else {
      "gaOr must be a list containing objects that all inherit from the class .gaExpr"
    }
  }
)

setClass(
  Class = "gaAnd",
  contains = "list",
  validity = function(object) {
    if (all(sapply(object@.Data, is, "gaOr"))) {
      TRUE
    } else {
      "gaAnd must be a list containing objects all of the class gaOr"
    }
  }
)

# ---- Simple and compound expression class union ----

setClassUnion(
  name = ".gaCompoundExpr",
  members = c(".gaExpr", "gaOr", "gaAnd")
)

# setClassUnion(
#   name = ".gaLogical",
#   members = c(".gaOperator",".gaCompoundExpr")
# )

# ---- GA filter ----

setClass(
  Class = "gaFilter",
  contains = "gaAnd",
  validity = function(object) {
    ## Check that single expressions within each OR expression exclusively
    ## belong to one class, i.e. either Metrics or Dimensions
    if (
      all(sapply(object@.Data, function(gaOr) {
        length(unique(sapply(gaOr, class))) == 1
      }))
    ) {
      TRUE
    } else {
      "An OR expression within a filter cannot mix metrics and dimensions."
    }
  }
)

# ---- GA dynamic and pre-defined segments ----

setClass(
  Class = ".gaDimensionOrMetricConditions",
  slots = c(
    negation = "logical"
  ),
  prototype = prototype(
    negation = FALSE
  ),
  contains = "VIRTUAL",
  validity = function(object) {
    validate_that(
      length(object@negation) == 1
    )
  }
)

setClass(
  Class = "gaSequenceStep",
  slots = c(
    immediatelyPrecedes = "logical"
  ),
  prototype = prototype(
    immediatelyPrecedes = FALSE
  ),
  contains = "gaAnd",
  validity = function(object) {
    validate_that(
      length(object@immediatelyPrecedes) == 1
    )
  }
)

setClass(
  Class = "gaSequenceCondition",
  contains = c("list", ".gaDimensionOrMetricConditions"),
  validity = function(object) {
    if (all(sapply(object@.Data, inherits, "gaSequenceStep"))) {
      TRUE
    } else {
      "All conditions within a sequence list must belong to the superclass gaSequenceStep."
    }
  }
)

setClass(
  Class = "gaNonSequenceCondition",
  contains = c("gaAnd", ".gaDimensionOrMetricConditions")
)

setClass(
  Class = "gaSegmentCondition",
  slots = c(
    conditionScope = "character"
  ),
  prototype = prototype(
    conditionScope = "sessions"
  ),
  contains = "list",
  validity = function(object) {
    if (!all(sapply(object@.Data, inherits, ".gaDimensionOrMetricConditions"))) {
      "All conditions within a gaSegmentCondition list must belong to the superclass .gaDimensionOrMetricConditions."
    } else if (length(object@conditionScope) != 1) {
      "Slot 'conditionScope' must be of length 1."
    } else if (!(object@conditionScope %in% c("users", "sessions"))) {
      "Slot 'conditionScope' must be either 'users' or 'sessions'."
    } else TRUE
  }
)

setClass(
  Class = "gaDynSegment",
  contains = "list",
  validity = function(object) {
    if (all(sapply(object@.Data, function(x) {inherits(x, "gaSegmentCondition")}))) {
      TRUE
    } else {
      "All objects with a gaDynSegment list must belong to the class gaSegmentCondition."
    } 
  }
)

setClass(
  Class = "gaSegmentId",
  contains = "character",
  validity = function(object) {
    pattern <- "^gaid::\\-?[0-9]+$"
    if (length(object) != 1) {
      "gaSegmentId must be a character vector of length 1"
    } else if (!grepl(pattern = pattern, x = object@.Data)) {
      paste("gaSegmentId must match the regular expression ", pattern, sep = "")
    } else TRUE
  }
)

setClassUnion(
  name = ".gaSegment",
  members = c("gaDynSegment", "gaSegmentId")
)

# ---- GA query dimensions, metrics, and sortby lists ----

setClass(
  Class = "gaDateRange",
  slots = c(
    startDate = "Date",
    endDate = "Date"
  ),
  prototype = prototype(
    startDate = Sys.Date() - 8,
    endDate = Sys.Date() - 1
  ),
  validity = function(object) {
    if (length(object@startDate) != length(object@endDate)) {
      "startDate and endDate must be the same length"
    } else if (all(object@startDate > object@endDate)) {
      "endDate cannot be before startDate"
    } else if (object@startDate < kGaDateOrigin) {
      paste("Start date cannot preceed Google Analytics launch date:", kGaDateOrigin)
    } else TRUE
  }
)

setClass(
  Class = "gaMetrics",
  prototype = prototype(
    list(new("gaMetVar"))
  ),
  contains = "list",
  validity = function(object) {
    if (!all(sapply(object, is, "gaMetVar"))) {
      "Must be a list containing objects of class gaMetVar"
    } else if (length(object) > kGaMax$metrics) {
      paste("Maximum of", kGaMax$metrics, "metrics allowed.", sep = " ")
    } else TRUE
  }
)

setClass(
  Class = "gaDimensions",
  prototype = prototype(
    list(new("gaDimVar"))
  ),
  contains = "list",
  validity = function(object) {
    if (!all(sapply(object, is, "gaDimVar"))) {
      "Must be a list containing objects of class gaDimVar"
    } else if (length(object) > kGaMax$dimensions) {
      paste("Maximum of", kGaMax$dimensions, "dimensions allowed.", sep = " ")
    } else TRUE
  }
)

setClass(
  Class = "gaSortBy",
  slots = c(
    desc = "logical"
  ),
  prototype = prototype(
    list(),
    desc = logical()
  ),
  contains = "list",
  validity = function(object) {
    if (!all(sapply(object@.Data, is, ".gaVar"))) {
      "Must be a list containing objects of class .gaVar"
    } else if (length(object@.Data) != length(object@desc)) {
      "List vector and desc vector must be of equal lengths"
    } else TRUE
  }
)

setClassUnion(
  name = ".gaVarList",
  members = c("gaMetrics", "gaDimensions", "gaSortBy"),
)

# ---- Ga Profile ID ----


setClass(
  Class = "gaProfileId",
  contains = "character",
  validity = function(object) {
    if (all(str_detect(object, "^ga:[0-9]+$"))) {
      TRUE
    } else {
      "gaProfileId must be an string of digits preceeded by 'ga:'"
    }
  }
)

# -- GA query construct ----

setClass(
  Class = "gaQuery",
  slots = c(
    profileId = "gaProfileId",
    dateRange = "gaDateRange",
    metrics = "gaMetrics",
    dimensions = "gaDimensions",
    sortBy = "gaSortBy",
    filters = "gaFilter",
    segment = ".gaSegment",
    samplingLevel = "character",
    maxResults = "numeric",
    creds = "list"
  ),
  prototype = prototype(
    dateRange = new("gaDateRange"),
    metrics = new("gaMetrics"),
    dimensions = new("gaDimensions"),
    sortBy = new("gaSortBy"),
    samplingLevel = "DEFAULT",
    maxResults = kGaMaxResults,
    creds = list()
  ),
  validity = function(object) {
    valid <- validate_that(
      length(object@maxResults) == 1,
      object@maxResults >= 1,
      length(object@samplingLevel) == 1
    )
    if (valid == TRUE) {
      if (object@maxResults > kGaMaxRows) {
        "maxResults cannot be greater than 1,000,000"
      } else if (!all(object@sortBy %in% union(object@metrics, object@dimensions))) {
        "sortBy must contain varNames also used as metrics and/or dimensions"
      } else if (!(object@samplingLevel %in% samplingLevel_levels)) {
        paste("samplingLevel must be one of:", paste(samplingLevel_levels, collapse = ", "))
      } else TRUE
    } else valid
  }
)

